非常好！下面为你 **完整、详细地实现 `Fody + Costura` 方案**，用于在 .NET 9.0 环境下将多个子项目（如 `0_Contracts`, `1_Contexts` 等）以及 NuGet 依赖（如 `Autofac`, `MediatR`, `R3` 等）**合并为一个单一的 `.dll` 文件**，并正确打包成 **NuGet 包**。

---

## ✅ 目标
- 去掉 `ILRepack`
- 使用 **Fody + Costura** 自动嵌入：
  - 第三方 NuGet 库（如 `Autofac.dll`, `MediatR.dll`）
  - 子项目的编译输出 DLL（可选）
- 最终生成 **单个 `ModularGodot.Core.dll`**
- 正常生成 `.nupkg` 并包含所有代码和依赖资源

---

## ✅ 整体方案设计

| 内容 | 处理方式 |
|------|----------|
| 子项目源码（Contracts, Contexts...） | 编译进主项目（通过 `<Compile Include=`）→ 真正合并到同一程序集 |
| 第三方 NuGet 包（Autofac, MediatR...） | 使用 `Costura.Fody` 将其 `.dll` 嵌入主程序集资源中 |
| 生成 NuGet 包 | 正常使用 `dotnet pack` |

> 💡 优点：无需 IL merge，运行时透明，兼容性好，适配 .NET 9.0 + AOT

---

## 🔧 第一步：修改主项目 —— `ModularGodot.Core.csproj`

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>

    <!-- NuGet 包信息 -->
    <PackageId>ModularGodot.Core</PackageId>
    <Version>0.1.0</Version>
    <Authors>BananaPeel</Authors>
    <Company>BananaPeel</Company>
    <Product>ModularGodot.Core</Product>
    <Description>A modular architecture framework for Godot applications, providing clean architecture patterns with dependency injection, CQRS, and domain-driven design support.</Description>
    <PackageTags>godot;modular;architecture;clean-architecture;ddd;cqrs;dependency-injection</PackageTags>
    <RepositoryUrl>https://github.com/1264459640/ModularGodot.Core</RepositoryUrl>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
    <IncludeSymbols>true</IncludeSymbols>
    <SymbolPackageFormat>snupkg</SymbolPackageFormat>
  
    <!-- 关键：允许 Fody 修改程序集 -->
    <AllowUnsafeBlocks>false</AllowUnsafeBlocks>
  </PropertyGroup>

  <!-- Step 1: 引入所有子项目的源码文件 -->
  <ItemGroup>
    <Compile Include="../0_Contracts/**/*.cs" />
    <Compile Include="../1_Contexts/**/*.cs" />
    <Compile Include="../2_Infrastructure/**/*.cs" />
    <Compile Include="../3_Repositories/**/*.cs" />

    <!-- 可选：保留目录结构显示在 VS 中 -->
    <None Include="../0_Contracts/**/*.cs" Link="Contracts\%(Filename)%(Extension)" />
    <None Include="../1_Contexts/**/*.cs" Link="Contexts\%(Filename)%(Extension)" />
    <None Include="../2_Infrastructure/**/*.cs" Link="Infrastructure\%(Filename)%(Extension)" />
    <None Include="../3_Repositories/**/*.cs" Link="Repositories\%(Filename)%(Extension)" />
  </ItemGroup>

  <!-- Step 2: 添加 NuGet 依赖（PrivateAssets=all 防止成为包依赖） -->
  <ItemGroup>
    <PackageReference Include="Autofac" Version="8.4.0">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="GodotSharp" Version="4.4.1">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="MediatR" Version="13.0.0">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="MediatR.Extensions.Autofac.DependencyInjection" Version="13.1.0">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.Extensions.Caching.Abstractions" Version="9.0.7">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.Extensions.Caching.Memory" Version="9.0.7">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="R3" Version="1.3.0">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="System.Reactive" Version="6.0.0">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <!-- Step 3: 安装 Fody + Costura（关键！） -->
  <ItemGroup>
    <PackageReference Include="Fody" Version="6.8.3">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Costura.Fody" Version="6.3.2">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <!-- 可选：隐藏嵌入的程序集从输出目录 -->
  <PropertyGroup>
    <CopyLocalLockFileAssemblies>false</CopyLocalLockFileAssemblies>
  </PropertyGroup>

  <!-- 允许测试项目访问 internal -->
  <ItemGroup>
    <AssemblyAttribute Include="System.Runtime.CompilerServices.InternalsVisibleTo">
      <_Parameter1>ModularGodot.Core.Test</_Parameter1>
    </AssemblyAttribute>
  </ItemGroup>
</Project>
```

---

## 📄 第二步：添加 `FodyWeavers.xml`

在 `ModularGodot.Core` 项目根目录创建文件：

### `FodyWeavers.xml`
```xml
<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <Costura>
    <!-- 可选配置 -->
    <DisableCleanup>true</DisableCleanup>
    <DisableCompression>true</DisableCompression>
    <PreloadOrder>
      <!-- 如果有加载顺序要求，例如 Autofac 必须先于插件 -->
    </PreloadOrder>
  </Costura>
</Weavers>
```

> 📝 提示：`.xsd` 文件不是必须的，但建议保留在项目里以支持智能提示。你可以在第一次构建后从 `obj/` 目录获取它。

---

## 🚫 第三步：删除或禁用子项目的独立构建

确保以下内容存在于每个子项目中（你已经做了）：

```xml
<!-- 所有子项目：0_Contracts.csproj, 1_Contexts.csproj 等 -->
<PropertyGroup>
  <TargetFramework>net9.0</TargetFramework>
  <GeneratePackageOnBuild>false</GeneratePackageOnBuild>
  <IsPackable>false</IsPackable>
  <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
</PropertyGroup>
```

不要在主项目中再使用 `<ProjectReference>`！

---

## ✅ 构建流程说明

1. 运行 `dotnet build` 或在 Visual Studio 中编译：
   - 所有 `.cs` 文件被纳入 `ModularGodot.Core` 编译过程
   - 编译完成后，Fody 在 IL 层织入初始化逻辑
   - Costura 自动将 `Autofac.dll`, `MediatR.dll`, `R3.dll` 等复制为资源，并注入 `AssemblyResolve` 事件

2. 输出：
   ```
   bin/Debug/net9.0/
     ModularGodot.Core.dll           ← 主程序集（含所有源码 + 嵌入式DLL）
     ModularGodot.Core.pdb
     (没有其他 .dll！)
   ```

3. 打包：
   ```bash
   dotnet pack
   ```
   生成：
   - `ModularGodot.Core.0.1.0.nupkg`
   - 包含：`lib/net9.0/*.dll`, `.pdb`, 嵌入资源等

---

## 🔍 验证是否成功合并

你可以用工具检查：

### 方法 1：用 ILSpy 或 dnSpy 打开 `ModularGodot.Core.dll`

- 查看“Resources”节点
- 应能看到类似：
  ```
  Costura.Autofac.dll
  Costura.MediatR.dll
  Costura.R3.dll
  ...
  ```

### 方法 2：运行时打印已加载程序集
```csharp
foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
{
    Console.WriteLine(asm.FullName);
}
```
应只看到 `ModularGodot.Core`, `mscorlib`, `System.*` 等，**不会有多余的 Autofac.dll 单独加载**

---

## ⚠️ 注意事项与坑点

| 问题 | 解决方法 |
|------|----------|
| `GodotSharp.dll` 是否能嵌入？ | ✅ 可以，只要不是 native DLL；GodotSharp 是托管包装器 |
| `MediatR.Extensions.Autofac.DependencyInjection` 类型找不到？ | 确保调用了 `services.AddMediatR(...)` 或 `builder.RegisterMediatR(...)`，避免裁剪 |
| 反射失败（TypeLoadException）？ | 启用 `[DynamicDependency]` 或设置 `<PublishTrimmed>false</PublishTrimmed>` |
| AOT 编译报错？ | 如果未来开启 Native AOT，请使用 `<TrimmerRootAssembly>true</TrimmerRootAssembly>` 保留关键类型 |

---

## 🔄 替代优化（高级用户）

如果你想保留 `ProjectReference` 结构用于 IDE 导航和编译验证，可以这样做：

```xml
<ItemGroup Condition="'$(BuildingInsideVisualStudio)' != 'true' Or '$(DesignTimeBuild)' == 'true'">
  <!-- 设计时仍可用 ProjectReference 提供语法补全 -->
  <ProjectReference Include="../0_Contracts/0_Contracts.csproj" PrivateAssets="all" />
  <ProjectReference Include="../1_Contexts/1_Contexts.csproj" PrivateAssets="all" />
</ItemGroup>

<ItemGroup Condition="'$(BuildingInsideVisualStudio)' == 'true' And '$(DesignTimeBuild)' != 'true'">
  <!-- 构建时改用源码引用 -->
  <Compile Remove="..\*\*.cs" />
  <Compile Include="../0_Contracts/**/*.cs" />
  ...
</ItemGroup>
```

但对多数项目，直接 `Compile Include` 更简单可靠。

---

## 🎉 成果总结

✅ 现在你拥有了：

- 一个真正的 **单 `.dll` 输出**
- 没有 `ILRepack`（过时）
- 支持 `.NET 9.0`
- 兼容 `dotnet pack`, CI/CD, GitHub Actions
- 易维护、可调试、高性能

---

## 📦 推荐后续操作

1. 【可选】使用 `MinVer` 自动版本管理
2. 【可选】添加 GitVersion 或 Nerdbank.GitVersioning
3. 发布到 NuGet.org / GitHub Packages
4. 在 `ModularGodot.App` 项目中引用该包测试功能完整性

---

如果你需要我生成完整的项目模板 ZIP 或 GitHub Action 脚本来自动发布，也可以告诉我！

祝你的 `ModularGodot.Core` 成为最受欢迎的 Godot 架构框架之一 🚀✨